#include <ctype.h>
import "std/string.zc"
/* Both of these are required for the 2 pass assembler.*/
import "statementlist.zc"
import "symboltable.zc"

raw {
//  typedef enum { _DB } Directive;
//  typedef enum { _INSTRUCTION, _DIRECTIVE } StatementType; --> Next stage of shit todo. T_T
  typedef enum {
    _MOV = 1, _ADD, _SUB, _JMP, _PUSH, _POP,_LEA, _SYSCALL,
    _INVALID = -1
  } Instrs;
  typedef enum { _REG, _CONST, _LABEL, _MEM_INDIRECT, _MEM_DISP } opTypes;
}

struct Operand{
  types:int;
  union { 
    reg:int; 
    constant:int;
    labelName:string;
    mem:Memory;
  };
}

struct Memory {
  baseReg:int;
  disp:int;
}
struct MachineCode {
  bytes:byte*;
  size:usize;
}

@derive(Copy)
struct Statement {
  instrs:int;
  op1:Operand;
  op2:Operand;
}

fn parseStatement(line:string) -> Statement {
  let stmt:Statement;
  let mnem:string = strtok(line, " \t\n");   
  stmt.op1.types = _INVALID;
  stmt.op2.types = _INVALID;

  if(mnem==NULL) {
    stmt.instrs = _INVALID;
    return stmt;
  }

  match(mnem) {
    "mov" => {
      stmt.instrs = _MOV;
      let op1:string = strtok(NULL, ", \t\n");
      if(op1) {
        if(op1[0] == '[') {
          if(!parseMemOperand(op1, &stmt.op1)) {
            printf("!! parseMemOperand failed on MOV [reg], .. with %s\n",op1);
            stmt.instrs = _INVALID;
            return stmt;
          }
        } else {
          stmt.op1.types = _REG;
          stmt.op1.reg = registerMap(op1);
        }
      }
      let op2:string = strtok(NULL, ", \t\n");
      if(op2) {
        if(op2[0] == '[') {
          if(!parseMemOperand(op2, &stmt.op2)) {
            stmt.instrs = _INVALID;
            return stmt;
          }
        } else {
          stmt.op2.types = _CONST;
          stmt.op2.constant = atoi(op2);
        }
      }
    },
    "lea" => {
      stmt.instrs = _LEA;
      let op1:string = strtok(NULL, ", \t\n");
      if(op1) {
        stmt.op1.types = _REG;
        stmt.op1.reg = registerMap(op1);
      }
      let op2:string = strtok(NULL, ", \t\n");
      if(op2) {
        if(op2[0] == '[') {
          if(!parseMemOperand(op2, &stmt.op2)) {
            stmt.instrs = _INVALID;
            return stmt;
          }
        } else {
          stmt.instrs = _INVALID;
          return stmt;
        }
      }
    },
    "add" => {
      stmt.instrs = _ADD;
      let op1:string = strtok(NULL, ", \t\n");
      if(op1) {
        stmt.op1.types = _REG;
        stmt.op1.reg = registerMap(op1);
      }
      let op2:string = strtok(NULL, ", \n\t");
      if(op2) {
        stmt.op2.types = _CONST;
        stmt.op2.constant = atoi(op2);
      }
    },
    "sub" => {
      stmt.instrs = _SUB;
      let op1:string = strtok(NULL, ", \t\n");
      if(op1) {
        stmt.op1.types = _REG;
        stmt.op1.reg = registerMap(op1);
      }
      let op2:string = strtok(NULL, ", \t\n");
      if(op2) {
        stmt.op2.types = _CONST;
        stmt.op2.constant = atoi(op2);
      }
    },
    "push" => {
      stmt.instrs = _PUSH;
      let op1:string = strtok(NULL, " \t\n");
      if(op1) {
        if(op1[0] == '[') {
          if(!parseMemOperand(op1, &stmt.op1)) {
            stmt.instrs = _INVALID;
            return stmt;
          }
        } else {
          stmt.op1.types = _REG;
          stmt.op1.reg = registerMap(op1);
        }
      }
    },
    "pop" => {
      stmt.instrs = _POP;
      let op1:string = strtok(NULL, " \t\n");
      if(op1) {
        if(op1[0] == '[') {
          if(!parseMemOperand(op1, &stmt.op1)) {
            stmt.instrs = _INVALID;
            return stmt;
          }
        } else {
          stmt.instrs = _REG;
          stmt.op1.reg = registerMap(op1);
        }
      }
    },
    "jmp" => {
      stmt.instrs = _JMP;
      let op1:string = strtok(NULL, " \t\n");
      if(op1) {
        stmt.op1.types = _CONST;
        stmt.op1.constant = strtol(op1, NULL, 0);
      }
    },
    "syscall" => {
      stmt.instrs = _SYSCALL;
    },
    _ => { stmt.instrs = _INVALID; }
  }
  return stmt;
}

fn assembleStatement(stmt:Statement) -> MachineCode {
  let mc = MachineCode { bytes:NULL, size:0 };
  let code:byte* = NULL;
  let size:usize = 0;
  let hasSib:int = 0;
  let sibByte:byte = 0x24; // [RSP] stuffs. (Scale=1, Index=RSP, Base=RSP); < ScaleIndexBase(SIB byte ^_^)

  match(stmt.instrs) {
    _MOV => {
      if(stmt.op1.types == _REG && stmt.op2.types == _CONST) {
        // mov reg, imm32 -> 48 BB imm32
        size = 6                      //instruction size.
        code = (byte *)malloc(size);  //Free'd later on.
        code[0] = 0x48;               //REX.W
        code[1] = 0xBB + stmt.op1.reg;            //Opcode + reg
        *((u32 *)(code+2)) = stmt.op2.constant;  //imm32
      } 
      else if (stmt.op1.types == _REG && stmt.op2.types == _REG) {
        //mov reg, reg  -> 48 89 /r 
        size = 3;
        code = (byte *)malloc(size);
        code[0] = 0x48;
        code[1] = 0x89;     //MOV r/m64, r64
        code[2] = (0b11 << 6) | (stmt.op2.reg << 3) | stmt.op1.reg; // ModR/M  
      }
      // Here comes the 'fun' part...... Yay! -.-
      else if (stmt.op1.types == _REG && stmt.op2.types == _MEM_INDIRECT) {
       // mov reg, [base reg] -> 48 bb /r
       //  ModR/M -> Mod=00 Reg=op1.reg R/M=op2.baseReg 
        hasSib = (stmt.op2.mem.baseReg == 4);

        size = 3 + hasSib; // REX.W + Opcode + ModR/M + optional SIB.
        code = (byte *)malloc(size);
        code[0] = 0x48;
        code[1] = 0xBB;
        code[2] = (0x00 << 6) | (stmt.op1.reg << 3) | stmt.op2.mem.baseReg; // ModR/M
        if(hasSib) { code[3] = sibByte; }
      }
      else if(stmt.op1.types == _MEM_INDIRECT && stmt.op2.types == _REG) {
      //   mov [base_reg], reg -> 48 89 /r
        hasSib = (stmt.op1.mem.baseReg == 4);

        size = 3 + hasSib;
        code = (byte *)malloc(size);
        code[0] = 0x48;
        code[1] = 0x89;
        code[2] = (0x00 << 6) | (stmt.op2.reg << 3) | stmt.op1.mem.baseReg;
        if(hasSib) { code[3] = sibByte; }
      }
      else if(stmt.op1.types == _REG && stmt.op2.types == _MEM_DISP) {
        // mov reg, [base_reg + disp32] - > 48 8B /r +disp32
        // ModR/M -> Mod=10, reg=op1.reg R/M=op2.baseReg
        hasSib = (stmt.op2.mem.baseReg == 4);

        size = 7 + hasSib;
        code = (byte *)malloc(size);
        code[0] = 0x48;
        code[1] = 0x8B;
        code[2] = (0x02 << 6) | (stmt.op1.reg << 3) | stmt.op2.mem.baseReg;

        if(hasSib) {
          code[3] = sibByte;
          *((u32 *)(code +4)) = stmt.op2.mem.disp;
        } else {
          *((u32 *)(code +3)) = stmt.op2.mem.disp;
        }
      }
      
      else if (stmt.op1.types == _MEM_DISP && stmt.op2.types == _REG) {
        // mov [base_reg + disp32], reg -> 48 89 /r + Disp32
        hasSib = (stmt.op1.mem.baseReg == 4);

        size = 7 + hasSib;
        code = (byte *)malloc(size);
        code[0] = 0x48;
        code[1] = 0x89;
        code[2] = (0x02 << 6) | (stmt.op2.reg << 3) | stmt.op1.mem.baseReg;

        if(hasSib) {
          code[3] = sibByte;
          *((u32 *)(code + 4)) = stmt.op1.mem.disp;
        } else {
          *((u32 *)(code + 3)) = stmt.op1.mem.disp;
        }
      }
      
    },
    _LEA => {
      if(stmt.op1.types == _REG && stmt.op2.types == _MEM_INDIRECT) {
        // lea reg, [base_reg] -> 48 8D /r
        // ModR/M -> Mod=00, Reg=op1.reg, RM=op2.baseReg
        hasSib = (stmt.op2.mem.baseReg == 4);

        size = 3 + hasSib;
        code = (byte *)malloc(size);
        code[0] = 0x48;
        code[1] = 0x8D;
        code[2] = (0x00 << 6) | (stmt.op1.reg << 3) | stmt.op2.mem.baseReg;
        if(hasSib) { code[3] = sibByte; }
      }
      else if(stmt.op1.types == _REG && stmt.op2.types == _MEM_DISP) {
        // lea reg, [base_req + disp32] -> 48 8D /r + disp32
        // ModR/M -> Mod=10, reg=op1.reg, R/M=op2.baseReg
        hasSib = (stmt.op2.mem.baseReg == 4);

        size = 7 + hasSib;  // REX.Q + Opcode + ModR/M + optional SIB + disp32
        code = (byte *)malloc(size);
        code[0] = 0x48;
        code[1] = 0x8D;
        code[2] = (0x02 << 6) | (stmt.op1.reg << 3) | stmt.op2.mem.baseReg;

        if(hasSib) {
          code[3] = sibByte;
          *((u32 *)(code + 4)) = stmt.op2.mem.disp;
        } else {
          *((u32 *)(code + 3)) = stmt.op2.mem.disp;
        }
      }
    },
    _ADD => {
      if(stmt.op1.types == _REG && stmt.op2.types == _CONST) {
        // add reg, imm32 -> 48 81 c0/c3 imm32
        size = 7;
        code = (byte *)malloc(size);
        code[0] = 0x48; 
        code[1] = 0x81; 
        code[2] = 0X0 + stmt.op1.reg;    //ModR/M (C0 for RAX, C3 for rbx )
        *((u32 *)(code+1)) = stmt.op2.constant;
      }
    },
    _SUB => {
      if (stmt.op1.types == _REG && stmt.op2.types == _CONST) {
        // sub rax, imm32 -> 48 81 E8 imm32
        size = 7;
        code = (byte *)malloc(size);
        code[0] = 0x48; 
        code[1] = 0x81;
        code[2] = 0xE8 + stmt.op1.reg; // ModR/M (0xE8 for RAX, 0xEB for RBX)
        *((u32 *)(code+3)) = stmt.op2.constant; // imm32
      }
    },
    _PUSH => {
      if(stmt.op1.types == _REG) {
        size =1;
        code = (byte *)malloc(size);
        code[0] = 0x50 + stmt.op1.reg;
      }
    },
    _POP => {
      if(stmt.op1.types == _REG) {
        size = 1;
        code = (byte *)malloc(size);
        code[0] = 0x58 + stmt.op1.reg;
      }
    },
    _JMP => {
      if(stmt.op1.types == _CONST) {
        size = 5;
        code = (byte *)malloc(size);
        code[0] = 0xE9;                           //jmp
        *((u32 *)(code +1)) = stmt.op1.constant;  //imm32
      }
    },
    _SYSCALL => {
      size = 2;
      code = (byte *)malloc(size);
      code[0] = 0x0F;
      code[1] = 0x05;
    }
  } //end match
  mc.bytes = code;
  mc.size = size;
  return mc;
}

fn registerMap(regName:string) -> int {
  match (regName) {
    "rax" => return 0,
    "rbx" => return 1,
    "rcx" => return 2,
    "rdx" => return 3,
    "rsp" => return 4;
    "rbp" => return 5;
    "rsi" => return 6;
    "rdi" => return 7;
  }
  return -1;
}

fn parseMemOperand(opStr:string, operand:Operand*) -> int { 
  if(opStr == NULL || strlen(opStr) < 3 || opStr[0] != '[' || opStr[strlen(opStr)-1] != ']') 
    return 0;
  let inner:string = strdup(opStr + 1);
  inner[strlen(inner)-1] = '\0';
  let tok:string = strtok(inner, " + ");
  if(tok == NULL) { 
    free(inner); 
    return 0; 
  }
  operand.mem.baseReg = registerMap(tok);
  if(operand.mem.baseReg == -1) {
    free(inner);
    return 0;
  }
  tok = strtok(NULL, " + ");
  if(tok == NULL) {
    operand.types = _MEM_INDIRECT;
    operand.mem.disp = 0;
  } else {
    operand.types = _MEM_DISP;
    operand.mem.disp = strtol(tok, NULL, 0);
  }
  free(inner);
  return 1;
}

/* 
   This things fucked.
   Didn't look that far into it.. It works(kinda) for now. Fix it later.. T_T
*/
fn parse(input:FILE*, output:FILE*, symtable:SymbolTable*, pass:int, stmtlist:StatementList*) {
  let line:string = NULL;
  let len:usize = 0;
  let read:usize;
  let curAddress:usize = 0;

  line = (string)malloc(128);
  if(line == NULL) {
    !"!! parse() -> malloc shat the bed. "
    exit(-1);
  }
  len = 128;

  // pass 1.
  if(pass == 1) {
    fseek(input, 0, SEEK_SET);
    while((read=getline(&line, &len, input))!=-1) {
      let linecpy:string = strdup(line);
      if(linecpy==NULL) {
        !"! Parse(1) -> Strdup shat the bed.. :["
        exit(-1);
      }
      linecpy[strcspn(linecpy, "\n")] = '\0';
      let trimLine = linecpy;
      while(isspace((char)*trimLine)) { trimLine++; }
      //Comments / newlines etc D:
      if(strlen(trimLine) == 0 || trimLine[0] == ';') { free(linecpy); continue; }
      let instrPart:string = trimLine;
      let labelEnd:string = strchr(trimLine, ':');
      if(labelEnd != NULL) {
        *labelEnd = '\0';
        let labelName = trimLine;
        let labelNameEnd = labelName + strlen(labelName) - 1;
        while (labelNameEnd >= labelName && isspace((char )*labelNameEnd)) { *labelNameEnd-- = '\0' }
        if(strlen(labelName)>0) {
          addSym(symtable, labelName, curAddress);
        } else {
          !"!! parse(1) -> Symbol Table is empty? Dafuq?"
          exit(-1);
        }
        instrPart = labelEnd + 1;
        while(isspace((char)*instrPart)) { instrPart++; }
        if(strlen(instrPart) == 0) {
          free(linecpy);
          continue;
        }
      }
      // JMP processing(JNE JE JL JG etc would go here too)
      let stmt:Statement = parseStatement(instrPart);
      if(stmt.instrs != _INVALID) {
        let tmp:Statement = stmt;
        if(tmp.instrs == _JMP && tmp.op1.types == _LABEL) {
          tmp.op1.types = _CONST;
          tmp.op1.constant = 0;        //Place holder for calcs in pass 2. 
        }
        let mc:MachineCode = assembleStatement(tmp);
        if(mc.bytes != NULL) {
          curAddress += mc.size;
          //free(mc.bytes);      //<- Fuck knows why this is being called multiple times/causes seg faults... *shrugs*
          addStatementToList(stmtlist, stmt);
        } else {
          !"!! Parse -> Couldn't assemble statment, ask ChatGPT."
          if(stmt.instrs == _JMP && stmt.op1.types == _LABEL) { free(stmt.op1.labelName);}
          exit(-1);
        }
      } else {
        !"!! Parse -> Invalid statement. Kinda like this one."
        exit(-1);
      }
      free(linecpy); 
    }
  } 
  else {   // Pass 2 - Code generation.. Hold onto your socks..
    let mcs:MachineCode*;
    let nmc:usize = 0;
    let cmc:usize =0;
    let i:usize = 0;

    curAddress = 0;
    for(i = 0; i < stmtlist.count; i++) {
      let stmt:Statement = stmtlist.statements[i];

      //Handle relative jumps.
      if(stmt.instrs == _JMP && stmt.op1.types == _LABEL) {
        let foundSym:Symbol* = findSym(symtable, stmt.op1.labelName);
        if(foundSym == NULL) {
          !"!! Parse(2) -> findSym didn't find shit... invalid label.."
          exit(-1);
        }
        let targetAddr = foundSym.address;
        let instrSize = 0;
        //JMP is 5 bytes -> E9 + 4 byte displacement(relative to the NEXT instruction).
        if(stmt.instrs == _JMP) { instrSize = 5; }
        stmt.op1.constant = targetAddr - (curAddress + instrSize); //Our rel jmp address. ^_^
        stmt.op1.types = _CONST;
      }
      let mc:MachineCode = assembleStatement(stmt);
      if(mc.bytes != NULL) {
        if(nmc == cmc) {
          //A dynamic array's probably not the best way to go here but whatever..
          cmc = (cmc == 0) ? 1 : cmc * 2;
          mcs = (MachineCode *)realloc(mcs, cmc * sizeof(MachineCode));
          if(mcs == NULL) {
            !"!! Parse(2) -> realloc again... Srsly.."
            exit(-1);
          }
        }
        mcs[nmc++] = mc;
        curAddress += mc.size;
      } else {
        !"!! Parse(2) - Couldn't assemble in Phase 2.. :["
        exit(-1);
      }
    }
    i = 0;
    for(i = 0; i < nmc; i++){
      if(output == stdout) {
        let j:usize = 0;
        let x=mcs[i].size;
        for(j =0; j < x; j++) { fprintf(output, "%02X ", mcs[i].bytes[j]); }
        fprintf(output, "\n");
      } else { fwrite(mcs[i].bytes, 1, mcs[i].size, output);}
      //free(mcs[i].bytes);               // << Srsly, dafuq is up with these things ..
    }
    free(mcs);
  }
  free(line);
}

fn main(argc:int, argv:string*) -> int {
  if(argc < 2) {
    "Usage: zencembler <file.asm>"
  } else {
    let file:string = argv[1];
    let inp:FILE* = fopen(argv[1], "r");
    let outp:FILE* = stdout;
    if(argc > 2) {
      outp = fopen(argv[3], "wb");
      if(outp == NULL) {
        !"!! Failed to open output file.."
        fclose(inp);
        return -1;
      }
    }
    let symtable:SymbolTable* = createSymTable();
    let stmtlist:StatementList* = createStatementList();

    //pass 1: Build sym and parse statements.
    rewind(inp);
    parse(inp, NULL, symtable, 1, stmtlist);
    //Pass 2: Gen machine code from the stored statement list.
    parse(NULL, outp, symtable, 2, stmtlist);
    if(symtable != NULL) { freeSymTable(symtable) };
    if(stmtlist != NULL) { freeStatementList(stmtlist); }
    fclose(inp);
    if(outp != stdout) { fclose(outp); } 
  }
  return 0;
}
